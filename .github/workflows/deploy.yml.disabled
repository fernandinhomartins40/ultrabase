name: Deploy Supabase Instance Manager com Versionamento

# Configuração de concorrência para evitar deploys simultâneos
concurrency:
  group: ultrabase-deploy-production
  cancel-in-progress: true

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'supabase-core/**'
      - 'scripts/**'
      - 'package*.json'
      - 'Dockerfile*'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      deploy_type:
        description: 'Tipo de deploy'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - backup-only
        - verify-only
        - rollback
      backup_retention:
        description: 'Quantos backups manter'
        required: false
        default: '10'
        type: string
      force_deploy:
        description: 'Forçar deploy mesmo com falhas menores'
        required: false
        default: false
        type: boolean

env:
  VPS_HOST: '82.25.69.57'
  VPS_USER: 'root'
  DEPLOY_DIR: '/opt/supabase-manager'
  BACKUP_DIR: '/opt/supabase-manager-backups'
  VERSION_TAG: 'v${{ github.run_number }}_${{ github.sha }}'

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - name: Check for concurrent deployments
      run: |
        echo "🔄 CONTROLE DE CONCORRÊNCIA - ULTRABASE"
        echo "======================================="
        echo "Grupo de concorrência: ultrabase-deploy-production"
        echo "Cancelar em progresso: SIM"
        echo "Run ID atual: ${{ github.run_id }}"
        echo "Run Number: ${{ github.run_number }}"
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        echo ""
        echo "🛑 IMPORTANTE: Workflows anteriores devem ser cancelados automaticamente"
        echo "======================================="
        
        # Aguardar um pouco para garantir que cancelamentos sejam processados
        sleep 5
        
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Precisamos do histórico completo para versionamento
        
    - name: Setup deployment info
      run: |
        echo "🚀 DEPLOY COM VERSIONAMENTO - Ultrabase"
        echo "======================================"
        echo "Versão: ${{ env.VERSION_TAG }}"
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        echo "Tipo: ${{ github.event.inputs.deploy_type || 'deploy' }}"
        echo "Run ID: ${{ github.run_id }}"
        echo "Concorrência: deploy-production-${{ github.ref }}"
        echo "======================================"
        
    - name: Execute Versioned Deploy
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ env.VPS_HOST }}
        username: ${{ env.VPS_USER }}
        key: ${{ secrets.VPS_PASSWORD }}
        port: 22
        timeout: 1800s  # 30 minutos
        command_timeout: 1800s
        script_stop: true
        script: |
          # ============================================================================
          # SISTEMA DE DEPLOY COM VERSIONAMENTO - ULTRABASE
          # ============================================================================
          
          set -euo pipefail
          
          # Cores para logs
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          BLUE='\033[0;34m'
          NC='\033[0m'
          
          # Função de log
          log() {
              echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
          }
          
          warn() {
              echo -e "${YELLOW}[WARNING] $1${NC}" >&2
          }
          
          error() {
              echo -e "${RED}[ERROR] $1${NC}" >&2
              exit 1
          }
          
          info() {
              echo -e "${BLUE}[INFO] $1${NC}"
          }
          
          # Configurações
          DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
          BACKUP_DIR="${{ env.BACKUP_DIR }}"
          VERSION_TAG="${{ env.VERSION_TAG }}"
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          DEPLOY_TYPE="${{ github.event.inputs.deploy_type }}"
          BACKUP_RETENTION="${{ github.event.inputs.backup_retention }}"
          FORCE_DEPLOY="${{ github.event.inputs.force_deploy }}"
          
          # Definir valores padrão para push automático
          if [ -z "$DEPLOY_TYPE" ]; then
              DEPLOY_TYPE="deploy"
          fi
          if [ -z "$BACKUP_RETENTION" ]; then
              BACKUP_RETENTION="10"
          fi
          if [ -z "$FORCE_DEPLOY" ]; then
              FORCE_DEPLOY="false"
          fi
          
          log "🚀 Iniciando deploy com versionamento - Versão: $VERSION_TAG"
          log "🆔 Run ID: ${{ github.run_id }}"
          
          # Verificar se há outros processos de deploy rodando
          DEPLOY_LOCK="/tmp/ultrabase-deploy.lock"
          if [ -f "$DEPLOY_LOCK" ]; then
              EXISTING_PID=$(cat "$DEPLOY_LOCK" 2>/dev/null)
              if ps -p "$EXISTING_PID" >/dev/null 2>&1; then
                  warn "⚠️ Deploy anterior ainda em execução (PID: $EXISTING_PID)"
                  warn "⚠️ GitHub Actions deveria ter cancelado, mas continuando..."
              else
                  log "🧹 Removendo lock de deploy anterior (processo não existe)"
                  rm -f "$DEPLOY_LOCK"
              fi
          fi
          
          # Criar lock para este deploy
          echo $$ > "$DEPLOY_LOCK"
          
          # Configurar trap para limpar lock em caso de erro ou saída
          cleanup_deploy() {
              log "🧹 Limpando lock de deploy..."
              rm -f "$DEPLOY_LOCK"
          }
          trap cleanup_deploy EXIT
          
          log "📋 Configurações do deploy:"
          log "   - DEPLOY_TYPE: $DEPLOY_TYPE"
          log "   - BACKUP_RETENTION: $BACKUP_RETENTION"
          log "   - FORCE_DEPLOY: $FORCE_DEPLOY"
          log "   - Disparado por: ${{ github.event_name }}"
          
          # ============================================================================
          # ETAPA 1: VERIFICAÇÕES PRÉ-DEPLOY
          # ============================================================================
          
          log "🔍 ETAPA 1: Verificações pré-deploy..."
          
          # Verificar se diretórios existem
          mkdir -p "$BACKUP_DIR"
          mkdir -p "$DEPLOY_DIR"
          
          # Verificar espaço em disco
          DISK_USAGE=$(df $DEPLOY_DIR | tail -1 | awk '{print $5}' | sed 's/%//')
          if [ "$DISK_USAGE" -gt 85 ]; then
              warn "Uso de disco alto: ${DISK_USAGE}%. Limpando backups antigos..."
              find "$BACKUP_DIR" -type d -name "v*" | sort | head -n -5 | xargs rm -rf
          fi
          
          # Verificar se Docker está rodando, instalar se necessário
          if ! docker info >/dev/null 2>&1; then
              warn "Docker não está disponível, tentando instalar..."
              
              # Instalar Docker se não estiver disponível
              if ! command -v docker >/dev/null 2>&1; then
                  log "📦 Instalando Docker..."
                  curl -fsSL https://get.docker.com -o get-docker.sh
                  sh get-docker.sh
                  systemctl start docker
                  systemctl enable docker
                  
                  # Aguardar Docker iniciar
                  sleep 10
                  
                  # Verificar novamente
                  if ! docker info >/dev/null 2>&1; then
                      warn "Docker instalado mas não funcionando, deploy continuará com PM2"
                  else
                      log "✅ Docker instalado e funcionando"
                  fi
              else
                  # Docker instalado mas não rodando
                  log "🔄 Iniciando Docker..."
                  systemctl start docker
                  sleep 5
                  
                  if ! docker info >/dev/null 2>&1; then
                      warn "Docker não conseguiu iniciar, deploy continuará com PM2"
                  fi
              fi
          fi
          
          log "✅ Verificações pré-deploy concluídas"
          
          # ============================================================================
          # ETAPA 2: BACKUP COMPLETO DO SISTEMA
          # ============================================================================
          
          if [ "$DEPLOY_TYPE" != "verify-only" ]; then
              log "📦 ETAPA 2: Criando backup completo..."
              
              BACKUP_PATH="$BACKUP_DIR/$VERSION_TAG"
              mkdir -p "$BACKUP_PATH"
              
              # Parar aplicação temporariamente para backup consistente
              log "⏸️ Parando aplicação para backup consistente..."
              if command -v pm2 >/dev/null 2>&1; then
                  pm2 stop supabase-manager 2>/dev/null || true
              fi
              
              # Backup do código da aplicação
              if [ -d "$DEPLOY_DIR" ]; then
                  log "📁 Backup do código da aplicação..."
                  tar -czf "$BACKUP_PATH/application-code.tar.gz" -C "$DEPLOY_DIR" . 2>/dev/null || true
              fi
              
              # Backup das instâncias (instances.json)
              if [ -f "$DEPLOY_DIR/src/instances.json" ]; then
                  log "📋 Backup das configurações de instâncias..."
                  cp "$DEPLOY_DIR/src/instances.json" "$BACKUP_PATH/instances.json"
              fi
              
              # Backup dos volumes Docker das instâncias
              if [ -d "$DEPLOY_DIR/supabase-core" ]; then
                  log "💾 Backup dos volumes Docker..."
                  find "$DEPLOY_DIR/supabase-core" -name 'volumes-*' -type d 2>/dev/null | while read volume_dir; do
                      if [ -d "$volume_dir" ]; then
                          instance_id=$(basename "$volume_dir" | sed 's/volumes-//')
                          tar -czf "$BACKUP_PATH/volumes-$instance_id.tar.gz" -C "$volume_dir" . 2>/dev/null || true
                      fi
                  done
              fi
              
              # Backup dos volumes Docker nomeados
              log "🐳 Backup dos volumes Docker nomeados..."
              docker volume ls -q | grep 'supabase-' 2>/dev/null | while read volume_name; do
                  docker run --rm -v "$volume_name:/volume" -v "$BACKUP_PATH:/backup" alpine tar -czf "/backup/docker-volume-$volume_name.tar.gz" -C /volume . 2>/dev/null || true
              done
              
              # Backup dos logs
              if [ -d "$DEPLOY_DIR/src/logs" ]; then
                  log "📝 Backup dos logs..."
                  tar -czf "$BACKUP_PATH/logs.tar.gz" -C "$DEPLOY_DIR/src/logs" . 2>/dev/null || true
              fi
              
              # Criar manifesto do backup
              cat > "$BACKUP_PATH/backup-manifest.json" << EOF
          {
              "timestamp": "$TIMESTAMP",
              "version": "$VERSION_TAG",
              "backup_type": "full",
              "git_commit": "${{ github.sha }}",
              "git_branch": "${{ github.ref_name }}",
              "deploy_type": "$DEPLOY_TYPE",
              "files": [
                  "application-code.tar.gz",
                  "instances.json",
                  "logs.tar.gz"
              ],
              "volumes_backed_up": $(ls "$BACKUP_PATH"/volumes-*.tar.gz 2>/dev/null | wc -l),
              "docker_volumes_backed_up": $(ls "$BACKUP_PATH"/docker-volume-*.tar.gz 2>/dev/null | wc -l)
          }
          EOF
              
              log "✅ Backup completo criado: $BACKUP_PATH"
          fi
          
          # Se é apenas backup, parar aqui
          if [ "$DEPLOY_TYPE" = "backup-only" ]; then
              log "🎯 Backup concluído. Deploy tipo: backup-only"
              log "⚠️ IMPORTANTE: Deploy foi configurado apenas para backup, parando aqui"
              exit 0
          fi
          
          log "▶️ Continuando com deploy completo (DEPLOY_TYPE: $DEPLOY_TYPE)"
          
          # ============================================================================
          # ETAPA 3: DEPLOY INCREMENTAL DA APLICAÇÃO
          # ============================================================================
          
          if [ "$DEPLOY_TYPE" = "deploy" ] || [ "$DEPLOY_TYPE" = "verify-only" ]; then
              log "🚀 ETAPA 3: Deploy incremental da aplicação..."
              log "📝 Executando deploy do tipo: $DEPLOY_TYPE"
              
              # Backup completo de todos os dados críticos
              log "💾 Preservando dados críticos..."
              mkdir -p "/tmp/preserve-$TIMESTAMP"
              
              # Preservar configurações de instâncias
              if [ -f "$DEPLOY_DIR/src/instances.json" ]; then
                  cp "$DEPLOY_DIR/src/instances.json" "/tmp/preserve-$TIMESTAMP/instances.json"
                  log "✅ instances.json preservado"
              fi
              
              # Preservar logs completos
              if [ -d "$DEPLOY_DIR/src/logs" ]; then
                  cp -r "$DEPLOY_DIR/src/logs" "/tmp/preserve-$TIMESTAMP/"
                  log "✅ logs preservados"
              fi
              
              # Preservar volumes de instâncias ativas
              if [ -d "$DEPLOY_DIR/supabase-core" ]; then
                  find "$DEPLOY_DIR/supabase-core" -name 'volumes-*' -type d 2>/dev/null | while read volume_dir; do
                      if [ -d "$volume_dir" ]; then
                          instance_id=$(basename "$volume_dir" | sed 's/volumes-//')
                          cp -r "$volume_dir" "/tmp/preserve-$TIMESTAMP/volumes-$instance_id" 2>/dev/null || true
                          log "✅ volumes-$instance_id preservados"
                      fi
                  done
              fi
              
              # Atualizar código apenas se não for verify-only
              if [ "$DEPLOY_TYPE" != "verify-only" ]; then
                  log "📥 Atualizando código (preservando dados)..."
                  cd "$DEPLOY_DIR"
                  
                  # Se não existe repositório, clonar
                  if [ ! -d ".git" ]; then
                      log "🆕 Clonando repositório..."
                      git clone https://github.com/fernandinhomartins40/ultrabase.git . || {
                          error "Falha ao clonar repositório"
                      }
                  else
                      # Deploy incremental: apenas pull das mudanças
                      log "🔄 Atualizando código incrementalmente..."
                      git fetch origin
                      
                      # Verificar se há mudanças
                      CURRENT_COMMIT=$(git rev-parse HEAD)
                      REMOTE_COMMIT=$(git rev-parse origin/main)
                      
                      if [ "$CURRENT_COMMIT" != "$REMOTE_COMMIT" ]; then
                          log "📝 Mudanças detectadas, aplicando..."
                          git pull origin main
                      else
                          log "📋 Código já atualizado, sem mudanças"
                      fi
                  fi
                  
                  # Restaurar TODOS os dados preservados
                  log "🔄 Restaurando dados preservados..."
                  
                  if [ -f "/tmp/preserve-$TIMESTAMP/instances.json" ]; then
                      cp "/tmp/preserve-$TIMESTAMP/instances.json" src/instances.json
                      log "✅ instances.json restaurado"
                  fi
                  
                  if [ -d "/tmp/preserve-$TIMESTAMP/logs" ]; then
                      cp -r "/tmp/preserve-$TIMESTAMP/logs" src/
                      log "✅ logs restaurados"
                  fi
                  
                  # Restaurar volumes de instâncias
                  if [ -d "/tmp/preserve-$TIMESTAMP" ]; then
                      find "/tmp/preserve-$TIMESTAMP" -name 'volumes-*' -type d 2>/dev/null | while read preserved_volume; do
                          volume_name=$(basename "$preserved_volume")
                          if [ ! -d "$DEPLOY_DIR/supabase-core/$volume_name" ]; then
                              mkdir -p "$DEPLOY_DIR/supabase-core"
                              cp -r "$preserved_volume" "$DEPLOY_DIR/supabase-core/"
                              log "✅ $volume_name restaurado"
                          fi
                      done
                  fi
                  
                  # Instalar dependências apenas se necessário
                  cd src
                  if [ package.json -nt node_modules/.package-json.timestamp ] || [ ! -f node_modules/.package-json.timestamp ]; then
                      log "📦 Atualizando dependências NPM..."
                      npm install --production
                      touch node_modules/.package-json.timestamp
                  else
                      log "📋 Dependências já atualizadas"
                  fi
              fi
              
              log "✅ Deploy incremental concluído - Dados preservados"
          fi
          
          # ============================================================================
          # ETAPA 4: REINICIAR APLICAÇÃO
          # ============================================================================
          
          # Sempre reiniciar aplicação, exceto para backup-only
          if [ "$DEPLOY_TYPE" != "backup-only" ]; then
              log "🔄 ETAPA 4: Reiniciando aplicação..."
              log "📝 Reiniciando para DEPLOY_TYPE: $DEPLOY_TYPE"
              
              cd "$DEPLOY_DIR/src"
              
              # Instalar PM2 se necessário
              if ! command -v pm2 >/dev/null 2>&1; then
                  log "📦 Instalando PM2..."
                  npm install -g pm2
              fi
              
              # Escolher método de deploy: Docker Compose (preferido) ou PM2 (fallback)
              log "🤖 Tentando deploy com Docker Compose..."
              cd "$DEPLOY_DIR/src/docker"
              
              # Verificar se Docker está funcionando
              if docker info >/dev/null 2>&1; then
                  log "✅ Docker disponível - Usando Docker Compose"
                  
                  # Parar containers existentes
                  docker compose -f docker-compose.production.yml down 2>/dev/null || true
                  
                  # Construir e iniciar containers
                  docker compose -f docker-compose.production.yml up -d --build --force-recreate
                  
                  # Aguardar containers ficarem prontos
                  log "⏳ Aguardando containers iniciarem (60 segundos)..."
                  sleep 60
                  
                  # Verificar se containers estão rodando
                  if docker ps | grep -q "supabase-instance-manager\|supabase-manager-nginx"; then
                      log "✅ Containers iniciados com sucesso"
                      DEPLOY_METHOD="docker"
                  else
                      log "❌ Containers falharam - Usando fallback PM2"
                      docker compose -f docker-compose.production.yml down 2>/dev/null || true
                      DEPLOY_METHOD="pm2"
                  fi
              else
                  log "❌ Docker não disponível - Usando PM2"
                  DEPLOY_METHOD="pm2"
              fi
              
              # Fallback para PM2 se Docker falhar
              if [ "$DEPLOY_METHOD" = "pm2" ]; then
                  log "🚀 Iniciando com PM2..."
                  cd "$DEPLOY_DIR/src"
                  
                  # Instalar PM2 se necessário
                  if ! command -v pm2 >/dev/null 2>&1; then
                      npm install -g pm2
                  fi
                  
                  # Parar PM2 existente
                  pm2 stop supabase-manager 2>/dev/null || true
                  pm2 delete supabase-manager 2>/dev/null || true
                  
                  # Iniciar aplicação
                  pm2 start server.js --name supabase-manager
                  
                  # Instalar nginx local se necessário (para PM2)
                  if ! command -v nginx >/dev/null 2>&1; then
                      log "📦 Instalando nginx..."
                      apt update && apt install -y nginx
                  fi
                  
                  # Configurar nginx para PM2
                  cp "$DEPLOY_DIR/src/docker/nginx.conf" /etc/nginx/nginx.conf
                  systemctl restart nginx
                  systemctl enable nginx
                  
                  # Aguardar aplicação ficar online
                  log "⏳ Aguardando aplicação ficar online..."
                  sleep 15
              fi
              
              log "✅ Aplicação reiniciada"
          fi
          
          # ============================================================================
          # ETAPA 5: VERIFICAÇÕES PÓS-DEPLOY
          # ============================================================================
          
          log "🔍 ETAPA 5: Verificações pós-deploy..."
          
          # Verificar se serviços estão rodando baseado no método de deploy
          if [ "${DEPLOY_METHOD:-pm2}" = "docker" ]; then
              if ! docker ps | grep -q "supabase-instance-manager\|supabase-manager-nginx"; then
                  error "Containers Docker não encontrados"
              fi
              log "✅ Containers Docker estão rodando"
          else
              if ! pm2 list | grep -q supabase-manager; then
                  error "PM2 process não encontrado"
              fi
              log "✅ PM2 process está rodando"
          fi
          
          # Verificar se aplicação responde
          HEALTH_ATTEMPTS=0
          MAX_HEALTH_ATTEMPTS=12
          
          while [ $HEALTH_ATTEMPTS -lt $MAX_HEALTH_ATTEMPTS ]; do
              if curl -f -s http://localhost:3080/api/health >/dev/null 2>&1; then
                  log "✅ Health check: OK"
                  break
              else
                  HEALTH_ATTEMPTS=$((HEALTH_ATTEMPTS + 1))
                  log "⏳ Health check tentativa $HEALTH_ATTEMPTS/$MAX_HEALTH_ATTEMPTS..."
                  sleep 10
              fi
          done
          
          if [ $HEALTH_ATTEMPTS -eq $MAX_HEALTH_ATTEMPTS ]; then
              error "Health check falhou após $MAX_HEALTH_ATTEMPTS tentativas"
          fi
          
          # Verificar API de instâncias
          if curl -f -s http://localhost:3080/api/instances >/dev/null 2>&1; then
              log "✅ API de instâncias: OK"
          else
              warn "API de instâncias não responde, mas continuando..."
          fi
          
          # Verificar instâncias existentes e dados preservados
          if [ -f "$DEPLOY_DIR/src/instances.json" ] && [ -s "$DEPLOY_DIR/src/instances.json" ]; then
              INSTANCE_COUNT=$(cat "$DEPLOY_DIR/src/instances.json" | jq '.instances | length' 2>/dev/null || echo "0")
              NEXT_PORT=$(cat "$DEPLOY_DIR/src/instances.json" | jq '.nextPort' 2>/dev/null || echo "8100")
              log "📊 Instâncias preservadas: $INSTANCE_COUNT"
              log "📊 Próxima porta disponível: $NEXT_PORT"
              
              # Verificar se volumes foram preservados
              if [ -d "$DEPLOY_DIR/supabase-core" ]; then
                  VOLUME_COUNT=$(find "$DEPLOY_DIR/supabase-core" -name 'volumes-*' -type d 2>/dev/null | wc -l)
                  log "📊 Volumes de dados preservados: $VOLUME_COUNT"
              fi
              
              # Verificar logs preservados
              if [ -d "$DEPLOY_DIR/src/logs" ] && [ "$(ls -A "$DEPLOY_DIR/src/logs" 2>/dev/null)" ]; then
                  LOG_FILES=$(ls "$DEPLOY_DIR/src/logs" 2>/dev/null | wc -l)
                  log "📊 Arquivos de log preservados: $LOG_FILES"
              fi
          else
              log "📋 Sistema iniciando sem instâncias prévias"
          fi
          
          log "✅ Verificações pós-deploy concluídas"
          
          # ============================================================================
          # ETAPA 6: LIMPEZA DE BACKUPS ANTIGOS
          # ============================================================================
          
          if [ "$DEPLOY_TYPE" = "deploy" ]; then
              log "🧹 ETAPA 6: Limpando backups antigos..."
              
              if [ -d "$BACKUP_DIR" ]; then
                  ls -1 "$BACKUP_DIR/" | grep -E '^v' | sort -r | tail -n +$((BACKUP_RETENTION + 1)) | while read old_backup; do
                      log "🗑️ Removendo backup antigo: $old_backup"
                      rm -rf "$BACKUP_DIR/$old_backup"
                  done
              fi
              
              log "✅ Limpeza concluída"
          fi
          
          # ============================================================================
          # RESULTADO FINAL
          # ============================================================================
          
          log "🎉 DEPLOY COM VERSIONAMENTO CONCLUÍDO!"
          log "======================================"
          log "✅ Versão: $VERSION_TAG"
          log "✅ Commit: ${{ github.sha }}"
          log "✅ Tipo: $DEPLOY_TYPE"
          log "✅ Método: ${DEPLOY_METHOD:-pm2}"
          log "✅ Backup: $BACKUP_DIR/$VERSION_TAG"
          log ""
          log "🌐 Aplicação disponível:"
          log "   - Dashboard: http://${{ env.VPS_HOST }}"
          log "   - API: http://${{ env.VPS_HOST }}:3080"
          log "   - Health: http://${{ env.VPS_HOST }}:3080/api/health"
          log ""
          log "📋 Status dos serviços:"
          if [ "${DEPLOY_METHOD:-pm2}" = "docker" ]; then
              docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "supabase-.*|NAMES" || true
              log "📋 Últimos logs da aplicação:"
              docker logs supabase-instance-manager --tail 3 2>/dev/null || true
          else
              if command -v pm2 >/dev/null 2>&1; then
                  pm2 list | grep supabase-manager || true
              fi
              if command -v systemctl >/dev/null 2>&1; then
                  systemctl status nginx --no-pager -l | head -3 2>/dev/null || true
              fi
          fi
          log ""
          log "🔄 Para rollback se necessário:"
          log "   bash scripts/deploy-versioning.sh rollback $VERSION_TAG"
          
    - name: Report deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "✅ Deploy com versionamento concluído com sucesso!"
          echo "🔗 Aplicação: http://${{ env.VPS_HOST }}"
          echo "📊 Versão: ${{ env.VERSION_TAG }}"
        else
          echo "❌ Deploy falhou!"
          echo "🔄 Execute rollback manual se necessário:"
          echo "   bash scripts/deploy-versioning.sh rollback"
        fi