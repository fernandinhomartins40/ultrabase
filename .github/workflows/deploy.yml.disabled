name: Deploy Supabase Instance Manager com Versionamento

# ConfiguraÃ§Ã£o de concorrÃªncia para evitar deploys simultÃ¢neos
concurrency:
  group: ultrabase-deploy-production
  cancel-in-progress: true

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'supabase-core/**'
      - 'scripts/**'
      - 'package*.json'
      - 'Dockerfile*'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      deploy_type:
        description: 'Tipo de deploy'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - backup-only
        - verify-only
        - rollback
      backup_retention:
        description: 'Quantos backups manter'
        required: false
        default: '10'
        type: string
      force_deploy:
        description: 'ForÃ§ar deploy mesmo com falhas menores'
        required: false
        default: false
        type: boolean

env:
  VPS_HOST: '82.25.69.57'
  VPS_USER: 'root'
  DEPLOY_DIR: '/opt/supabase-manager'
  BACKUP_DIR: '/opt/supabase-manager-backups'
  VERSION_TAG: 'v${{ github.run_number }}_${{ github.sha }}'

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - name: Check for concurrent deployments
      run: |
        echo "ğŸ”„ CONTROLE DE CONCORRÃŠNCIA - ULTRABASE"
        echo "======================================="
        echo "Grupo de concorrÃªncia: ultrabase-deploy-production"
        echo "Cancelar em progresso: SIM"
        echo "Run ID atual: ${{ github.run_id }}"
        echo "Run Number: ${{ github.run_number }}"
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        echo ""
        echo "ğŸ›‘ IMPORTANTE: Workflows anteriores devem ser cancelados automaticamente"
        echo "======================================="
        
        # Aguardar um pouco para garantir que cancelamentos sejam processados
        sleep 5
        
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Precisamos do histÃ³rico completo para versionamento
        
    - name: Setup deployment info
      run: |
        echo "ğŸš€ DEPLOY COM VERSIONAMENTO - Ultrabase"
        echo "======================================"
        echo "VersÃ£o: ${{ env.VERSION_TAG }}"
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        echo "Tipo: ${{ github.event.inputs.deploy_type || 'deploy' }}"
        echo "Run ID: ${{ github.run_id }}"
        echo "ConcorrÃªncia: deploy-production-${{ github.ref }}"
        echo "======================================"
        
    - name: Execute Versioned Deploy
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ env.VPS_HOST }}
        username: ${{ env.VPS_USER }}
        key: ${{ secrets.VPS_PASSWORD }}
        port: 22
        timeout: 1800s  # 30 minutos
        command_timeout: 1800s
        script_stop: true
        script: |
          # ============================================================================
          # SISTEMA DE DEPLOY COM VERSIONAMENTO - ULTRABASE
          # ============================================================================
          
          set -euo pipefail
          
          # Cores para logs
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          BLUE='\033[0;34m'
          NC='\033[0m'
          
          # FunÃ§Ã£o de log
          log() {
              echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
          }
          
          warn() {
              echo -e "${YELLOW}[WARNING] $1${NC}" >&2
          }
          
          error() {
              echo -e "${RED}[ERROR] $1${NC}" >&2
              exit 1
          }
          
          info() {
              echo -e "${BLUE}[INFO] $1${NC}"
          }
          
          # ConfiguraÃ§Ãµes
          DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
          BACKUP_DIR="${{ env.BACKUP_DIR }}"
          VERSION_TAG="${{ env.VERSION_TAG }}"
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          DEPLOY_TYPE="${{ github.event.inputs.deploy_type }}"
          BACKUP_RETENTION="${{ github.event.inputs.backup_retention }}"
          FORCE_DEPLOY="${{ github.event.inputs.force_deploy }}"
          
          # Definir valores padrÃ£o para push automÃ¡tico
          if [ -z "$DEPLOY_TYPE" ]; then
              DEPLOY_TYPE="deploy"
          fi
          if [ -z "$BACKUP_RETENTION" ]; then
              BACKUP_RETENTION="10"
          fi
          if [ -z "$FORCE_DEPLOY" ]; then
              FORCE_DEPLOY="false"
          fi
          
          log "ğŸš€ Iniciando deploy com versionamento - VersÃ£o: $VERSION_TAG"
          log "ğŸ†” Run ID: ${{ github.run_id }}"
          
          # Verificar se hÃ¡ outros processos de deploy rodando
          DEPLOY_LOCK="/tmp/ultrabase-deploy.lock"
          if [ -f "$DEPLOY_LOCK" ]; then
              EXISTING_PID=$(cat "$DEPLOY_LOCK" 2>/dev/null)
              if ps -p "$EXISTING_PID" >/dev/null 2>&1; then
                  warn "âš ï¸ Deploy anterior ainda em execuÃ§Ã£o (PID: $EXISTING_PID)"
                  warn "âš ï¸ GitHub Actions deveria ter cancelado, mas continuando..."
              else
                  log "ğŸ§¹ Removendo lock de deploy anterior (processo nÃ£o existe)"
                  rm -f "$DEPLOY_LOCK"
              fi
          fi
          
          # Criar lock para este deploy
          echo $$ > "$DEPLOY_LOCK"
          
          # Configurar trap para limpar lock em caso de erro ou saÃ­da
          cleanup_deploy() {
              log "ğŸ§¹ Limpando lock de deploy..."
              rm -f "$DEPLOY_LOCK"
          }
          trap cleanup_deploy EXIT
          
          log "ğŸ“‹ ConfiguraÃ§Ãµes do deploy:"
          log "   - DEPLOY_TYPE: $DEPLOY_TYPE"
          log "   - BACKUP_RETENTION: $BACKUP_RETENTION"
          log "   - FORCE_DEPLOY: $FORCE_DEPLOY"
          log "   - Disparado por: ${{ github.event_name }}"
          
          # ============================================================================
          # ETAPA 1: VERIFICAÃ‡Ã•ES PRÃ‰-DEPLOY
          # ============================================================================
          
          log "ğŸ” ETAPA 1: VerificaÃ§Ãµes prÃ©-deploy..."
          
          # Verificar se diretÃ³rios existem
          mkdir -p "$BACKUP_DIR"
          mkdir -p "$DEPLOY_DIR"
          
          # Verificar espaÃ§o em disco
          DISK_USAGE=$(df $DEPLOY_DIR | tail -1 | awk '{print $5}' | sed 's/%//')
          if [ "$DISK_USAGE" -gt 85 ]; then
              warn "Uso de disco alto: ${DISK_USAGE}%. Limpando backups antigos..."
              find "$BACKUP_DIR" -type d -name "v*" | sort | head -n -5 | xargs rm -rf
          fi
          
          # Verificar se Docker estÃ¡ rodando, instalar se necessÃ¡rio
          if ! docker info >/dev/null 2>&1; then
              warn "Docker nÃ£o estÃ¡ disponÃ­vel, tentando instalar..."
              
              # Instalar Docker se nÃ£o estiver disponÃ­vel
              if ! command -v docker >/dev/null 2>&1; then
                  log "ğŸ“¦ Instalando Docker..."
                  curl -fsSL https://get.docker.com -o get-docker.sh
                  sh get-docker.sh
                  systemctl start docker
                  systemctl enable docker
                  
                  # Aguardar Docker iniciar
                  sleep 10
                  
                  # Verificar novamente
                  if ! docker info >/dev/null 2>&1; then
                      warn "Docker instalado mas nÃ£o funcionando, deploy continuarÃ¡ com PM2"
                  else
                      log "âœ… Docker instalado e funcionando"
                  fi
              else
                  # Docker instalado mas nÃ£o rodando
                  log "ğŸ”„ Iniciando Docker..."
                  systemctl start docker
                  sleep 5
                  
                  if ! docker info >/dev/null 2>&1; then
                      warn "Docker nÃ£o conseguiu iniciar, deploy continuarÃ¡ com PM2"
                  fi
              fi
          fi
          
          log "âœ… VerificaÃ§Ãµes prÃ©-deploy concluÃ­das"
          
          # ============================================================================
          # ETAPA 2: BACKUP COMPLETO DO SISTEMA
          # ============================================================================
          
          if [ "$DEPLOY_TYPE" != "verify-only" ]; then
              log "ğŸ“¦ ETAPA 2: Criando backup completo..."
              
              BACKUP_PATH="$BACKUP_DIR/$VERSION_TAG"
              mkdir -p "$BACKUP_PATH"
              
              # Parar aplicaÃ§Ã£o temporariamente para backup consistente
              log "â¸ï¸ Parando aplicaÃ§Ã£o para backup consistente..."
              if command -v pm2 >/dev/null 2>&1; then
                  pm2 stop supabase-manager 2>/dev/null || true
              fi
              
              # Backup do cÃ³digo da aplicaÃ§Ã£o
              if [ -d "$DEPLOY_DIR" ]; then
                  log "ğŸ“ Backup do cÃ³digo da aplicaÃ§Ã£o..."
                  tar -czf "$BACKUP_PATH/application-code.tar.gz" -C "$DEPLOY_DIR" . 2>/dev/null || true
              fi
              
              # Backup das instÃ¢ncias (instances.json)
              if [ -f "$DEPLOY_DIR/src/instances.json" ]; then
                  log "ğŸ“‹ Backup das configuraÃ§Ãµes de instÃ¢ncias..."
                  cp "$DEPLOY_DIR/src/instances.json" "$BACKUP_PATH/instances.json"
              fi
              
              # Backup dos volumes Docker das instÃ¢ncias
              if [ -d "$DEPLOY_DIR/supabase-core" ]; then
                  log "ğŸ’¾ Backup dos volumes Docker..."
                  find "$DEPLOY_DIR/supabase-core" -name 'volumes-*' -type d 2>/dev/null | while read volume_dir; do
                      if [ -d "$volume_dir" ]; then
                          instance_id=$(basename "$volume_dir" | sed 's/volumes-//')
                          tar -czf "$BACKUP_PATH/volumes-$instance_id.tar.gz" -C "$volume_dir" . 2>/dev/null || true
                      fi
                  done
              fi
              
              # Backup dos volumes Docker nomeados
              log "ğŸ³ Backup dos volumes Docker nomeados..."
              docker volume ls -q | grep 'supabase-' 2>/dev/null | while read volume_name; do
                  docker run --rm -v "$volume_name:/volume" -v "$BACKUP_PATH:/backup" alpine tar -czf "/backup/docker-volume-$volume_name.tar.gz" -C /volume . 2>/dev/null || true
              done
              
              # Backup dos logs
              if [ -d "$DEPLOY_DIR/src/logs" ]; then
                  log "ğŸ“ Backup dos logs..."
                  tar -czf "$BACKUP_PATH/logs.tar.gz" -C "$DEPLOY_DIR/src/logs" . 2>/dev/null || true
              fi
              
              # Criar manifesto do backup
              cat > "$BACKUP_PATH/backup-manifest.json" << EOF
          {
              "timestamp": "$TIMESTAMP",
              "version": "$VERSION_TAG",
              "backup_type": "full",
              "git_commit": "${{ github.sha }}",
              "git_branch": "${{ github.ref_name }}",
              "deploy_type": "$DEPLOY_TYPE",
              "files": [
                  "application-code.tar.gz",
                  "instances.json",
                  "logs.tar.gz"
              ],
              "volumes_backed_up": $(ls "$BACKUP_PATH"/volumes-*.tar.gz 2>/dev/null | wc -l),
              "docker_volumes_backed_up": $(ls "$BACKUP_PATH"/docker-volume-*.tar.gz 2>/dev/null | wc -l)
          }
          EOF
              
              log "âœ… Backup completo criado: $BACKUP_PATH"
          fi
          
          # Se Ã© apenas backup, parar aqui
          if [ "$DEPLOY_TYPE" = "backup-only" ]; then
              log "ğŸ¯ Backup concluÃ­do. Deploy tipo: backup-only"
              log "âš ï¸ IMPORTANTE: Deploy foi configurado apenas para backup, parando aqui"
              exit 0
          fi
          
          log "â–¶ï¸ Continuando com deploy completo (DEPLOY_TYPE: $DEPLOY_TYPE)"
          
          # ============================================================================
          # ETAPA 3: DEPLOY INCREMENTAL DA APLICAÃ‡ÃƒO
          # ============================================================================
          
          if [ "$DEPLOY_TYPE" = "deploy" ] || [ "$DEPLOY_TYPE" = "verify-only" ]; then
              log "ğŸš€ ETAPA 3: Deploy incremental da aplicaÃ§Ã£o..."
              log "ğŸ“ Executando deploy do tipo: $DEPLOY_TYPE"
              
              # Backup completo de todos os dados crÃ­ticos
              log "ğŸ’¾ Preservando dados crÃ­ticos..."
              mkdir -p "/tmp/preserve-$TIMESTAMP"
              
              # Preservar configuraÃ§Ãµes de instÃ¢ncias
              if [ -f "$DEPLOY_DIR/src/instances.json" ]; then
                  cp "$DEPLOY_DIR/src/instances.json" "/tmp/preserve-$TIMESTAMP/instances.json"
                  log "âœ… instances.json preservado"
              fi
              
              # Preservar logs completos
              if [ -d "$DEPLOY_DIR/src/logs" ]; then
                  cp -r "$DEPLOY_DIR/src/logs" "/tmp/preserve-$TIMESTAMP/"
                  log "âœ… logs preservados"
              fi
              
              # Preservar volumes de instÃ¢ncias ativas
              if [ -d "$DEPLOY_DIR/supabase-core" ]; then
                  find "$DEPLOY_DIR/supabase-core" -name 'volumes-*' -type d 2>/dev/null | while read volume_dir; do
                      if [ -d "$volume_dir" ]; then
                          instance_id=$(basename "$volume_dir" | sed 's/volumes-//')
                          cp -r "$volume_dir" "/tmp/preserve-$TIMESTAMP/volumes-$instance_id" 2>/dev/null || true
                          log "âœ… volumes-$instance_id preservados"
                      fi
                  done
              fi
              
              # Atualizar cÃ³digo apenas se nÃ£o for verify-only
              if [ "$DEPLOY_TYPE" != "verify-only" ]; then
                  log "ğŸ“¥ Atualizando cÃ³digo (preservando dados)..."
                  cd "$DEPLOY_DIR"
                  
                  # Se nÃ£o existe repositÃ³rio, clonar
                  if [ ! -d ".git" ]; then
                      log "ğŸ†• Clonando repositÃ³rio..."
                      git clone https://github.com/fernandinhomartins40/ultrabase.git . || {
                          error "Falha ao clonar repositÃ³rio"
                      }
                  else
                      # Deploy incremental: apenas pull das mudanÃ§as
                      log "ğŸ”„ Atualizando cÃ³digo incrementalmente..."
                      git fetch origin
                      
                      # Verificar se hÃ¡ mudanÃ§as
                      CURRENT_COMMIT=$(git rev-parse HEAD)
                      REMOTE_COMMIT=$(git rev-parse origin/main)
                      
                      if [ "$CURRENT_COMMIT" != "$REMOTE_COMMIT" ]; then
                          log "ğŸ“ MudanÃ§as detectadas, aplicando..."
                          git pull origin main
                      else
                          log "ğŸ“‹ CÃ³digo jÃ¡ atualizado, sem mudanÃ§as"
                      fi
                  fi
                  
                  # Restaurar TODOS os dados preservados
                  log "ğŸ”„ Restaurando dados preservados..."
                  
                  if [ -f "/tmp/preserve-$TIMESTAMP/instances.json" ]; then
                      cp "/tmp/preserve-$TIMESTAMP/instances.json" src/instances.json
                      log "âœ… instances.json restaurado"
                  fi
                  
                  if [ -d "/tmp/preserve-$TIMESTAMP/logs" ]; then
                      cp -r "/tmp/preserve-$TIMESTAMP/logs" src/
                      log "âœ… logs restaurados"
                  fi
                  
                  # Restaurar volumes de instÃ¢ncias
                  if [ -d "/tmp/preserve-$TIMESTAMP" ]; then
                      find "/tmp/preserve-$TIMESTAMP" -name 'volumes-*' -type d 2>/dev/null | while read preserved_volume; do
                          volume_name=$(basename "$preserved_volume")
                          if [ ! -d "$DEPLOY_DIR/supabase-core/$volume_name" ]; then
                              mkdir -p "$DEPLOY_DIR/supabase-core"
                              cp -r "$preserved_volume" "$DEPLOY_DIR/supabase-core/"
                              log "âœ… $volume_name restaurado"
                          fi
                      done
                  fi
                  
                  # Instalar dependÃªncias apenas se necessÃ¡rio
                  cd src
                  if [ package.json -nt node_modules/.package-json.timestamp ] || [ ! -f node_modules/.package-json.timestamp ]; then
                      log "ğŸ“¦ Atualizando dependÃªncias NPM..."
                      npm install --production
                      touch node_modules/.package-json.timestamp
                  else
                      log "ğŸ“‹ DependÃªncias jÃ¡ atualizadas"
                  fi
              fi
              
              log "âœ… Deploy incremental concluÃ­do - Dados preservados"
          fi
          
          # ============================================================================
          # ETAPA 4: REINICIAR APLICAÃ‡ÃƒO
          # ============================================================================
          
          # Sempre reiniciar aplicaÃ§Ã£o, exceto para backup-only
          if [ "$DEPLOY_TYPE" != "backup-only" ]; then
              log "ğŸ”„ ETAPA 4: Reiniciando aplicaÃ§Ã£o..."
              log "ğŸ“ Reiniciando para DEPLOY_TYPE: $DEPLOY_TYPE"
              
              cd "$DEPLOY_DIR/src"
              
              # Instalar PM2 se necessÃ¡rio
              if ! command -v pm2 >/dev/null 2>&1; then
                  log "ğŸ“¦ Instalando PM2..."
                  npm install -g pm2
              fi
              
              # Escolher mÃ©todo de deploy: Docker Compose (preferido) ou PM2 (fallback)
              log "ğŸ¤– Tentando deploy com Docker Compose..."
              cd "$DEPLOY_DIR/src/docker"
              
              # Verificar se Docker estÃ¡ funcionando
              if docker info >/dev/null 2>&1; then
                  log "âœ… Docker disponÃ­vel - Usando Docker Compose"
                  
                  # Parar containers existentes
                  docker compose -f docker-compose.production.yml down 2>/dev/null || true
                  
                  # Construir e iniciar containers
                  docker compose -f docker-compose.production.yml up -d --build --force-recreate
                  
                  # Aguardar containers ficarem prontos
                  log "â³ Aguardando containers iniciarem (60 segundos)..."
                  sleep 60
                  
                  # Verificar se containers estÃ£o rodando
                  if docker ps | grep -q "supabase-instance-manager\|supabase-manager-nginx"; then
                      log "âœ… Containers iniciados com sucesso"
                      DEPLOY_METHOD="docker"
                  else
                      log "âŒ Containers falharam - Usando fallback PM2"
                      docker compose -f docker-compose.production.yml down 2>/dev/null || true
                      DEPLOY_METHOD="pm2"
                  fi
              else
                  log "âŒ Docker nÃ£o disponÃ­vel - Usando PM2"
                  DEPLOY_METHOD="pm2"
              fi
              
              # Fallback para PM2 se Docker falhar
              if [ "$DEPLOY_METHOD" = "pm2" ]; then
                  log "ğŸš€ Iniciando com PM2..."
                  cd "$DEPLOY_DIR/src"
                  
                  # Instalar PM2 se necessÃ¡rio
                  if ! command -v pm2 >/dev/null 2>&1; then
                      npm install -g pm2
                  fi
                  
                  # Parar PM2 existente
                  pm2 stop supabase-manager 2>/dev/null || true
                  pm2 delete supabase-manager 2>/dev/null || true
                  
                  # Iniciar aplicaÃ§Ã£o
                  pm2 start server.js --name supabase-manager
                  
                  # Instalar nginx local se necessÃ¡rio (para PM2)
                  if ! command -v nginx >/dev/null 2>&1; then
                      log "ğŸ“¦ Instalando nginx..."
                      apt update && apt install -y nginx
                  fi
                  
                  # Configurar nginx para PM2
                  cp "$DEPLOY_DIR/src/docker/nginx.conf" /etc/nginx/nginx.conf
                  systemctl restart nginx
                  systemctl enable nginx
                  
                  # Aguardar aplicaÃ§Ã£o ficar online
                  log "â³ Aguardando aplicaÃ§Ã£o ficar online..."
                  sleep 15
              fi
              
              log "âœ… AplicaÃ§Ã£o reiniciada"
          fi
          
          # ============================================================================
          # ETAPA 5: VERIFICAÃ‡Ã•ES PÃ“S-DEPLOY
          # ============================================================================
          
          log "ğŸ” ETAPA 5: VerificaÃ§Ãµes pÃ³s-deploy..."
          
          # Verificar se serviÃ§os estÃ£o rodando baseado no mÃ©todo de deploy
          if [ "${DEPLOY_METHOD:-pm2}" = "docker" ]; then
              if ! docker ps | grep -q "supabase-instance-manager\|supabase-manager-nginx"; then
                  error "Containers Docker nÃ£o encontrados"
              fi
              log "âœ… Containers Docker estÃ£o rodando"
          else
              if ! pm2 list | grep -q supabase-manager; then
                  error "PM2 process nÃ£o encontrado"
              fi
              log "âœ… PM2 process estÃ¡ rodando"
          fi
          
          # Verificar se aplicaÃ§Ã£o responde
          HEALTH_ATTEMPTS=0
          MAX_HEALTH_ATTEMPTS=12
          
          while [ $HEALTH_ATTEMPTS -lt $MAX_HEALTH_ATTEMPTS ]; do
              if curl -f -s http://localhost:3080/api/health >/dev/null 2>&1; then
                  log "âœ… Health check: OK"
                  break
              else
                  HEALTH_ATTEMPTS=$((HEALTH_ATTEMPTS + 1))
                  log "â³ Health check tentativa $HEALTH_ATTEMPTS/$MAX_HEALTH_ATTEMPTS..."
                  sleep 10
              fi
          done
          
          if [ $HEALTH_ATTEMPTS -eq $MAX_HEALTH_ATTEMPTS ]; then
              error "Health check falhou apÃ³s $MAX_HEALTH_ATTEMPTS tentativas"
          fi
          
          # Verificar API de instÃ¢ncias
          if curl -f -s http://localhost:3080/api/instances >/dev/null 2>&1; then
              log "âœ… API de instÃ¢ncias: OK"
          else
              warn "API de instÃ¢ncias nÃ£o responde, mas continuando..."
          fi
          
          # Verificar instÃ¢ncias existentes e dados preservados
          if [ -f "$DEPLOY_DIR/src/instances.json" ] && [ -s "$DEPLOY_DIR/src/instances.json" ]; then
              INSTANCE_COUNT=$(cat "$DEPLOY_DIR/src/instances.json" | jq '.instances | length' 2>/dev/null || echo "0")
              NEXT_PORT=$(cat "$DEPLOY_DIR/src/instances.json" | jq '.nextPort' 2>/dev/null || echo "8100")
              log "ğŸ“Š InstÃ¢ncias preservadas: $INSTANCE_COUNT"
              log "ğŸ“Š PrÃ³xima porta disponÃ­vel: $NEXT_PORT"
              
              # Verificar se volumes foram preservados
              if [ -d "$DEPLOY_DIR/supabase-core" ]; then
                  VOLUME_COUNT=$(find "$DEPLOY_DIR/supabase-core" -name 'volumes-*' -type d 2>/dev/null | wc -l)
                  log "ğŸ“Š Volumes de dados preservados: $VOLUME_COUNT"
              fi
              
              # Verificar logs preservados
              if [ -d "$DEPLOY_DIR/src/logs" ] && [ "$(ls -A "$DEPLOY_DIR/src/logs" 2>/dev/null)" ]; then
                  LOG_FILES=$(ls "$DEPLOY_DIR/src/logs" 2>/dev/null | wc -l)
                  log "ğŸ“Š Arquivos de log preservados: $LOG_FILES"
              fi
          else
              log "ğŸ“‹ Sistema iniciando sem instÃ¢ncias prÃ©vias"
          fi
          
          log "âœ… VerificaÃ§Ãµes pÃ³s-deploy concluÃ­das"
          
          # ============================================================================
          # ETAPA 6: LIMPEZA DE BACKUPS ANTIGOS
          # ============================================================================
          
          if [ "$DEPLOY_TYPE" = "deploy" ]; then
              log "ğŸ§¹ ETAPA 6: Limpando backups antigos..."
              
              if [ -d "$BACKUP_DIR" ]; then
                  ls -1 "$BACKUP_DIR/" | grep -E '^v' | sort -r | tail -n +$((BACKUP_RETENTION + 1)) | while read old_backup; do
                      log "ğŸ—‘ï¸ Removendo backup antigo: $old_backup"
                      rm -rf "$BACKUP_DIR/$old_backup"
                  done
              fi
              
              log "âœ… Limpeza concluÃ­da"
          fi
          
          # ============================================================================
          # RESULTADO FINAL
          # ============================================================================
          
          log "ğŸ‰ DEPLOY COM VERSIONAMENTO CONCLUÃDO!"
          log "======================================"
          log "âœ… VersÃ£o: $VERSION_TAG"
          log "âœ… Commit: ${{ github.sha }}"
          log "âœ… Tipo: $DEPLOY_TYPE"
          log "âœ… MÃ©todo: ${DEPLOY_METHOD:-pm2}"
          log "âœ… Backup: $BACKUP_DIR/$VERSION_TAG"
          log ""
          log "ğŸŒ AplicaÃ§Ã£o disponÃ­vel:"
          log "   - Dashboard: http://${{ env.VPS_HOST }}"
          log "   - API: http://${{ env.VPS_HOST }}:3080"
          log "   - Health: http://${{ env.VPS_HOST }}:3080/api/health"
          log ""
          log "ğŸ“‹ Status dos serviÃ§os:"
          if [ "${DEPLOY_METHOD:-pm2}" = "docker" ]; then
              docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "supabase-.*|NAMES" || true
              log "ğŸ“‹ Ãšltimos logs da aplicaÃ§Ã£o:"
              docker logs supabase-instance-manager --tail 3 2>/dev/null || true
          else
              if command -v pm2 >/dev/null 2>&1; then
                  pm2 list | grep supabase-manager || true
              fi
              if command -v systemctl >/dev/null 2>&1; then
                  systemctl status nginx --no-pager -l | head -3 2>/dev/null || true
              fi
          fi
          log ""
          log "ğŸ”„ Para rollback se necessÃ¡rio:"
          log "   bash scripts/deploy-versioning.sh rollback $VERSION_TAG"
          
    - name: Report deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "âœ… Deploy com versionamento concluÃ­do com sucesso!"
          echo "ğŸ”— AplicaÃ§Ã£o: http://${{ env.VPS_HOST }}"
          echo "ğŸ“Š VersÃ£o: ${{ env.VERSION_TAG }}"
        else
          echo "âŒ Deploy falhou!"
          echo "ğŸ”„ Execute rollback manual se necessÃ¡rio:"
          echo "   bash scripts/deploy-versioning.sh rollback"
        fi