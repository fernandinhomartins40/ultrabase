name: ğŸ”„ Deploy - Restaurar Estado Funcional

# Controle de concorrÃªncia
concurrency:
  group: ultrabase-restore-deploy
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      force_restore:
        description: 'ForÃ§ar restauraÃ§Ã£o completa'
        required: false
        default: 'false'

env:
  VPS_HOST: '82.25.69.57'
  VPS_USER: 'root'
  DEPLOY_DIR: '/opt/supabase-manager'

jobs:
  restore-deploy:
    name: ğŸ”„ Restaurar ao Estado Funcional
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: ğŸ“‹ Info da RestauraÃ§Ã£o
      run: |
        echo "ğŸ”„ RestauraÃ§Ã£o ao Estado Funcional - Ultrabase"
        echo "=============================================="
        echo "Commit de RestauraÃ§Ã£o: 079c450 (OpenSSL + JWT)"
        echo "Branch Atual: restore-working-state"
        echo "ForÃ§ar RestauraÃ§Ã£o: ${{ github.event.inputs.force_restore }}"
        echo "=============================================="

    - name: ğŸ“¥ Checkout do Estado Funcional
      uses: actions/checkout@v4
      with:
        ref: '079c45097c9aa01b8ea44c7a322bf13e31c733e4'
        fetch-depth: 1

    - name: ğŸ”‘ Configurar SSH
      run: |
        echo "ğŸ”‘ Configurando SSH para restauraÃ§Ã£o..."
        sudo apt-get update && sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts
        echo "âœ… SSH configurado"

    - name: ğŸ” Verificar estado atual da VPS
      id: vps-check
      run: |
        echo "ğŸ” Verificando estado atual da VPS..."
        
        # Verificar se Ã© primeira instalaÃ§Ã£o E se dependÃªncias existem
        FIRST_INSTALL="false"
        NEEDS_DEPS="false"
        NEEDS_APP_START="false"
        
        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo '=== Verificando Infraestrutura ==='
          
          # Verificar Docker
          if ! command -v docker >/dev/null 2>&1; then
            echo 'âŒ Docker: NÃƒO INSTALADO'
            FIRST_INSTALL='true'
          else
            echo \"âœ… Docker: \$(docker --version 2>/dev/null || echo 'VERSION ERROR')\"
          fi
          
          # Verificar Node.js
          if ! command -v node >/dev/null 2>&1; then
            echo 'âŒ Node.js: NÃƒO INSTALADO'
            FIRST_INSTALL='true'
          else
            echo \"âœ… Node.js: \$(node --version)\"
          fi
          
          # Verificar PM2
          if ! command -v pm2 >/dev/null 2>&1; then
            echo 'âŒ PM2: NÃƒO INSTALADO'
            FIRST_INSTALL='true'
          else
            echo 'âœ… PM2: INSTALADO'
          fi
          
          # Verificar Nginx
          if ! command -v nginx >/dev/null 2>&1; then
            echo 'âŒ Nginx: NÃƒO INSTALADO'
            FIRST_INSTALL='true'
          else
            echo 'âœ… Nginx: INSTALADO'
          fi
          
          # Verificar OpenSSL (necessÃ¡rio para chaves JWT)
          if ! command -v openssl >/dev/null 2>&1; then
            echo 'âŒ OpenSSL: NÃƒO INSTALADO'
            FIRST_INSTALL='true'
          else
            echo \"âœ… OpenSSL: \$(openssl version 2>/dev/null || echo 'VERSION ERROR')\"
          fi
          
          # Verificar diretÃ³rio da aplicaÃ§Ã£o
          if [ ! -d '${{ env.DEPLOY_DIR }}' ]; then
            echo 'âŒ DiretÃ³rio da aplicaÃ§Ã£o: NÃƒO EXISTE'
            FIRST_INSTALL='true'
          else
            echo 'âœ… DiretÃ³rio da aplicaÃ§Ã£o: EXISTE'
            
            # Verificar se dependÃªncias Node.js existem (CRÃTICO)
            if [ ! -d '${{ env.DEPLOY_DIR }}/src/node_modules' ] || [ ! -f '${{ env.DEPLOY_DIR }}/src/node_modules/express/package.json' ]; then
              echo 'âŒ DependÃªncias Node.js: FALTANDO'
              NEEDS_DEPS='true'
            else
              echo 'âœ… DependÃªncias Node.js: INSTALADAS'
            fi
            
            # Verificar se aplicaÃ§Ã£o estÃ¡ rodando no PM2
            export PATH='/usr/local/bin:\$PATH'
            if ! pm2 list 2>/dev/null | grep -q supabase-manager; then
              echo 'âŒ AplicaÃ§Ã£o PM2: NÃƒO RODANDO'
              NEEDS_APP_START='true'
            else
              echo 'âœ… AplicaÃ§Ã£o PM2: RODANDO'
            fi
          fi
          
          echo \"FIRST_INSTALL=\$FIRST_INSTALL\" > /tmp/install_check.txt
          echo \"NEEDS_DEPS=\$NEEDS_DEPS\" >> /tmp/install_check.txt
          echo \"NEEDS_APP_START=\$NEEDS_APP_START\" >> /tmp/install_check.txt
        " || echo -e "FIRST_INSTALL=true\nNEEDS_DEPS=true\nNEEDS_APP_START=true" > /tmp/vps_status.txt
        
        # Capturar resultados
        FIRST_INSTALL=$(sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "cat /tmp/install_check.txt 2>/dev/null | grep FIRST_INSTALL | cut -d'=' -f2" || echo "true")
        NEEDS_DEPS=$(sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "cat /tmp/install_check.txt 2>/dev/null | grep NEEDS_DEPS | cut -d'=' -f2" || echo "true")
        NEEDS_APP_START=$(sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "cat /tmp/install_check.txt 2>/dev/null | grep NEEDS_APP_START | cut -d'=' -f2" || echo "true")
        
        echo "first_install=$FIRST_INSTALL" >> $GITHUB_OUTPUT
        echo "needs_deps=$NEEDS_DEPS" >> $GITHUB_OUTPUT
        echo "needs_app_start=$NEEDS_APP_START" >> $GITHUB_OUTPUT
        
        echo "ğŸ Primeira instalaÃ§Ã£o: $FIRST_INSTALL"
        echo "ğŸ Precisa dependÃªncias: $NEEDS_DEPS"
        echo "ğŸ Precisa iniciar app: $NEEDS_APP_START"

    - name: ğŸš€ InstalaÃ§Ã£o Inicial Completa (primeira vez)
      if: steps.vps-check.outputs.first_install == 'true'
      run: |
        echo "ğŸš€ Executando instalaÃ§Ã£o inicial completa..."
        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          set -e
          echo 'ğŸ”„ Atualizando sistema...'
          export DEBIAN_FRONTEND=noninteractive
          apt-get update -y
          apt-get upgrade -y
          
          echo 'ğŸ³ Instalando Docker...'
          # Remover versÃµes antigas
          apt-get remove -y docker docker-engine docker.io containerd runc 2>/dev/null || true
          
          # Instalar dependÃªncias
          apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release
          
          # Adicionar chave GPG do Docker
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
          
          # Adicionar repositÃ³rio
          echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable\" | tee /etc/apt/sources.list.d/docker.list > /dev/null
          
          # Instalar Docker
          apt-get update -y
          apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
          
          # Iniciar Docker
          systemctl start docker
          systemctl enable docker
          
          echo 'âœ… Docker instalado'
          docker --version
          
          echo 'ğŸ“¦ Instalando Node.js 18...'
          curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
          apt-get install -y nodejs
          
          echo 'âœ… Node.js instalado'
          node --version
          npm --version
          
          echo 'ğŸŒ Instalando PM2...'
          npm install -g pm2
          
          # Recarregar ambiente para reconhecer PM2
          export PATH=\"/usr/local/bin:\$PATH\"
          hash -r
          
          # Configurar PM2 startup
          pm2 startup systemd -u root --hp /root
          
          echo 'âœ… PM2 instalado'
          pm2 --version
          
          echo 'ğŸŒ Instalando Nginx...'
          apt-get install -y nginx
          
          # Configurar Nginx bÃ¡sico
          echo 'server {' > /etc/nginx/sites-available/ultrabase
          echo '    listen 80;' >> /etc/nginx/sites-available/ultrabase
          echo '    server_name _;' >> /etc/nginx/sites-available/ultrabase
          echo '    access_log /var/log/nginx/ultrabase.access.log;' >> /etc/nginx/sites-available/ultrabase
          echo '    error_log /var/log/nginx/ultrabase.error.log;' >> /etc/nginx/sites-available/ultrabase
          echo '    location / {' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_pass http://127.0.0.1:3080;' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_http_version 1.1;' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_set_header Upgrade \$http_upgrade;' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_set_header Connection '\''upgrade'\'';' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_set_header Host \$host;' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_set_header X-Real-IP \$remote_addr;' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_set_header X-Forwarded-Proto \$scheme;' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_cache_bypass \$http_upgrade;' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_connect_timeout 60s;' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_send_timeout 60s;' >> /etc/nginx/sites-available/ultrabase
          echo '        proxy_read_timeout 60s;' >> /etc/nginx/sites-available/ultrabase
          echo '    }' >> /etc/nginx/sites-available/ultrabase
          echo '    location /health {' >> /etc/nginx/sites-available/ultrabase
          echo '        access_log off;' >> /etc/nginx/sites-available/ultrabase
          echo '        return 200 '\''healthy'\'';' >> /etc/nginx/sites-available/ultrabase
          echo '        add_header Content-Type text/plain;' >> /etc/nginx/sites-available/ultrabase
          echo '    }' >> /etc/nginx/sites-available/ultrabase
          echo '}' >> /etc/nginx/sites-available/ultrabase
          
          # Ativar site
          ln -sf /etc/nginx/sites-available/ultrabase /etc/nginx/sites-enabled/
          rm -f /etc/nginx/sites-enabled/default
          
          # Testar configuraÃ§Ã£o
          nginx -t
          
          # Iniciar Nginx
          systemctl start nginx
          systemctl enable nginx
          
          echo 'âœ… Nginx instalado e configurado'
          
          echo 'ğŸ“ Criando diretÃ³rios...'
          mkdir -p ${{ env.DEPLOY_DIR }}
          mkdir -p /opt/supabase-manager-backups
          mkdir -p /var/log/ultrabase
          
          echo 'ğŸ”§ Instalando ferramentas extras...'
          apt-get install -y jq curl wget git htop ufw openssl
          
          echo 'ğŸ”’ Configurando firewall bÃ¡sico...'
          ufw --force enable
          ufw allow ssh
          ufw allow 80
          ufw allow 443
          ufw --force reload
          
          echo 'ğŸ¯ InstalaÃ§Ã£o inicial completa!'
          echo '=== VersÃµes Instaladas ==='
          echo \"Docker: \$(docker --version)\"
          echo \"Node.js: \$(node --version)\"
          echo \"PM2: \$(pm2 --version)\"
          echo \"Nginx: \$(nginx -v 2>&1)\"
          echo \"OpenSSL: \$(openssl version)\"
        "

    - name: ğŸ“¦ Backup dos Dados Atuais
      run: |
        echo "ğŸ“¦ Fazendo backup dos dados atuais antes da restauraÃ§Ã£o..."
        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
          BACKUP_DIR=/opt/supabase-manager-backups/backup_before_restore_\$TIMESTAMP
          mkdir -p \$BACKUP_DIR
          
          # Backup crÃ­tico sempre
          if [ -f ${{ env.DEPLOY_DIR }}/src/instances.json ]; then
            cp ${{ env.DEPLOY_DIR }}/src/instances.json \$BACKUP_DIR/
            echo 'âœ… instances.json backed up'
          fi
          
          # Backup do estado atual se existir
          if [ -d ${{ env.DEPLOY_DIR }} ]; then
            tar -czf \$BACKUP_DIR/current_state.tar.gz -C ${{ env.DEPLOY_DIR }} . 2>/dev/null || echo 'Backup parcial'
          fi
          
          echo \"ğŸ“¦ Backup criado: \$BACKUP_DIR\"
        "

    - name: ğŸ”„ Restaurar ao Estado Funcional
      run: |
        echo "ğŸ”„ Restaurando ao commit funcional 079c450..."
        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.DEPLOY_DIR }}
          
          # Verificar se repositÃ³rio existe
          if [ ! -d .git ]; then
            echo 'ğŸ†• Primeira vez: clonando repositÃ³rio...'
            git clone https://github.com/fernandinhomartins40/ultrabase.git .
          else
            echo 'ğŸ“¥ Fazendo stash das mudanÃ§as atuais...'
            git stash push -m 'Backup antes da restauraÃ§Ã£o' 2>/dev/null || true
          fi
          
          echo 'ğŸ”„ Fazendo checkout para o commit funcional...'
          git fetch origin
          git checkout 079c45097c9aa01b8ea44c7a322bf13e31c733e4
          
          echo 'âœ… CÃ³digo restaurado ao estado funcional'
          echo 'Commit atual:'
          git log --oneline -1
        "

    - name: ğŸ”„ Restaurar Dados Preservados
      run: |
        echo "ğŸ”„ Restaurando dados crÃ­ticos..."
        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.DEPLOY_DIR }}
          
          # Procurar backup mais recente
          LATEST_BACKUP=\$(ls -t /opt/supabase-manager-backups/backup_before_restore_* 2>/dev/null | head -1 || echo '')
          
          if [ -n \"\$LATEST_BACKUP\" ] && [ -f \"\$LATEST_BACKUP/instances.json\" ]; then
            mkdir -p src
            cp \"\$LATEST_BACKUP/instances.json\" src/instances.json
            echo 'âœ… instances.json restaurado do backup'
          else
            echo 'âš ï¸ Nenhum backup de instances.json encontrado'
          fi
          
          echo 'ğŸ›¡ï¸ Dados crÃ­ticos preservados'
        "

    - name: ğŸ“¦ Instalar DependÃªncias
      run: |
        echo "ğŸ“¦ Instalando dependÃªncias do estado funcional..."
        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.DEPLOY_DIR }}/src
          echo 'Instalando dependÃªncias do Node.js...'
          npm install --production --silent
          echo 'âœ… DependÃªncias instaladas'
          
          # Verificar se instalaÃ§Ã£o foi bem-sucedida
          if [ -d node_modules ] && [ -f node_modules/express/package.json ]; then
            echo 'âœ… Express instalado corretamente'
          else
            echo 'âŒ Erro na instalaÃ§Ã£o das dependÃªncias'
            exit 1
          fi
        "

    - name: ğŸ”„ Reiniciar AplicaÃ§Ã£o
      run: |
        echo "ğŸ”„ Reiniciando aplicaÃ§Ã£o no estado funcional..."
        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.DEPLOY_DIR }}/src
          
          # Recarregar ambiente para PM2
          export PATH=\"/usr/local/bin:\$PATH\"
          hash -r
          
          # Parar aplicaÃ§Ã£o atual se existir
          pm2 stop supabase-manager 2>/dev/null || true
          pm2 delete supabase-manager 2>/dev/null || true
          
          echo 'ğŸš€ Iniciando aplicaÃ§Ã£o no estado funcional...'
          pm2 start server.js --name supabase-manager
          
          pm2 save
          echo 'âœ… AplicaÃ§Ã£o restaurada e iniciada'
        "

    - name: â³ Aguardar EstabilizaÃ§Ã£o
      run: |
        echo "â³ Aguardando aplicaÃ§Ã£o estabilizar..."
        sleep 15

    - name: ğŸ” VerificaÃ§Ã£o Final
      run: |
        echo "ğŸ” VerificaÃ§Ã£o final do estado restaurado..."
        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          # Recarregar ambiente
          export PATH=\"/usr/local/bin:\$PATH\"
          hash -r
          
          # Verificar PM2
          if pm2 list | grep -q supabase-manager; then
            echo 'âœ… PM2 rodando'
          else
            echo 'âŒ PM2 nÃ£o estÃ¡ rodando'
            exit 1
          fi
          
          # Verificar health check
          for i in {1..5}; do
            if curl -f -s http://localhost:3080/api/health >/dev/null 2>&1; then
              echo 'âœ… Health check OK'
              break
            else
              echo \"â³ Tentativa \$i/5...\"
              sleep 10
            fi
            
            if [ \$i -eq 5 ]; then
              echo 'âŒ Health check falhou apÃ³s 5 tentativas'
              exit 1
            fi
          done
        "

    - name: ğŸ“Š RelatÃ³rio da RestauraÃ§Ã£o
      if: always()
      run: |
        echo "ğŸ“Š RELATÃ“RIO DA RESTAURAÃ‡ÃƒO"
        echo "=========================="
        sshpass -p '${{ secrets.VPS_PASSWORD }}' ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo 'Estado Restaurado: Commit 079c450 (OpenSSL + JWT)'
          echo 'AplicaÃ§Ã£o Funcional: SIM'
          echo ''
          
          echo '=== Status da AplicaÃ§Ã£o ==='
          pm2 list --no-colors | grep -E 'name|supabase-manager' || echo 'PM2 nÃ£o encontrado'
          
          echo ''
          echo '=== InstÃ¢ncias Preservadas ==='
          if [ -f ${{ env.DEPLOY_DIR }}/src/instances.json ]; then
            INSTANCES=\$(cat ${{ env.DEPLOY_DIR }}/src/instances.json | jq '.instances | length' 2>/dev/null || echo '0')
            echo \"ğŸ“Š \$INSTANCES instÃ¢ncias preservadas\"
          else
            echo 'Nenhuma instÃ¢ncia encontrada'
          fi
          
          echo ''
          echo '=== Commit Atual ==='
          cd ${{ env.DEPLOY_DIR }} && git log --oneline -1
          
          echo ''
          echo '=== Ferramentas Verificadas ==='
          echo \"OpenSSL: \$(openssl version)\"
          echo \"Node.js: \$(node --version)\"
          echo \"PM2: \$(pm2 --version)\"
          
          echo ''
          echo 'ğŸ¯ AplicaÃ§Ã£o: http://${{ env.VPS_HOST }}/'
          echo 'âœ… Estado funcional restaurado!'
        "

    - name: ğŸ‰ RestauraÃ§Ã£o ConcluÃ­da
      run: |
        echo "ğŸ‰ RESTAURAÃ‡ÃƒO AO ESTADO FUNCIONAL CONCLUÃDA!"
        echo "ğŸ“ Commit Restaurado: 079c450"
        echo "ğŸ›¡ï¸ Dados Preservados: SIM"
        echo "ğŸš€ AplicaÃ§Ã£o: http://${{ env.VPS_HOST }}/"
        echo "âœ… Sistema funcionando no Ãºltimo estado estÃ¡vel"