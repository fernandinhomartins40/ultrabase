# Plano de Melhorias para Diagn√≥stico e Controle do Gerenciador de Inst√¢ncias

## An√°lise Atual do Sistema

### Componentes Identificados

#### 1. **Gerenciador de Inst√¢ncias (SupabaseInstanceManager)**
- **Localiza√ß√£o**: `src/server.js:311-1210`
- **Funcionalidade**: Controla cria√ß√£o, inicializa√ß√£o, parada e remo√ß√£o de inst√¢ncias
- **Pontos Cr√≠ticos**: 
  - M√©todo `createInstance()` com timeout de 10 minutos
  - Execu√ß√£o do script `generate-adapted.bash` para cria√ß√£o
  - Status b√°sico: 'creating', 'running', 'stopped', 'error'

#### 2. **Componente GoTrue (Autentica√ß√£o)**
- **Localiza√ß√£o**: Container `supabase-auth-${INSTANCE_ID}` no docker-compose
- **Imagem**: `supabase/gotrue:v2.167.0`
- **Configura√ß√£o**: Via vari√°veis de ambiente no `.env-${INSTANCE_ID}`
- **Problema Relatado**: "Failed to create user: API error happened while trying to communicate with the server"

#### 3. **Sistema de Logs Atual**
- **Vector Logging**: `supabase-core/volumes/logs/vector.yml`
- **Coleta**: Logs de todos os containers via Docker
- **Destino**: Logflare Analytics (`http://analytics:4000`)
- **Limita√ß√£o**: Logs n√£o s√£o facilmente acess√≠veis para diagn√≥stico

#### 4. **Monitoramento B√°sico**
- **Health Checks**: Implementados nos containers Docker
- **Status Verification**: M√©todo `getInstanceStatus()` verifica containers
- **Limita√ß√£o**: Apenas verifica se containers est√£o rodando

---

## Fases de Implementa√ß√£o

### **FASE 1: Sistema de Diagn√≥stico Sob Demanda** 
*Prioridade: ALTA | Dura√ß√£o: 3-5 dias*

#### Objetivo
Implementar ferramentas completas de diagn√≥stico que executam sob demanda (manual ou agendado) para identificar problemas em inst√¢ncias.

#### Implementa√ß√µes T√©cnicas

##### 1.1 Health Check Detalhado (Sob Demanda)
```javascript
// Nova classe para diagn√≥stico sob demanda
class InstanceDiagnostics {
  constructor() {
    this.lastDiagnosticCache = new Map(); // Cache para evitar execu√ß√µes desnecess√°rias
  }

  async runFullDiagnostic(instanceId) {
    console.log(`üîç Iniciando diagn√≥stico sob demanda para inst√¢ncia ${instanceId}`);
    
    const diagnostic = {
      timestamp: new Date().toISOString(),
      instance_id: instanceId,
      results: {
        container_status: await this.checkContainers(instanceId),
        service_health: await this.checkServices(instanceId),
        database_connection: await this.checkDatabase(instanceId),
        api_endpoints: await this.checkAPIEndpoints(instanceId),
        auth_service: await this.checkAuthService(instanceId),
        disk_usage: await this.checkDiskUsage(instanceId),
        network_connectivity: await this.checkNetworkConnectivity(instanceId)
      }
    };

    // Cache do √∫ltimo diagn√≥stico (v√°lido por 5 minutos)
    this.lastDiagnosticCache.set(instanceId, {
      data: diagnostic,
      expires: Date.now() + (5 * 60 * 1000)
    });

    return diagnostic;
  }

  async getLastDiagnostic(instanceId) {
    const cached = this.lastDiagnosticCache.get(instanceId);
    if (cached && cached.expires > Date.now()) {
      return cached.data;
    }
    return null;
  }

  // Diagn√≥stico r√°pido para uso ap√≥s opera√ß√µes de reparo
  async quickHealthCheck(instanceId) {
    return {
      timestamp: new Date().toISOString(),
      healthy: await this.isInstanceHealthy(instanceId),
      critical_services: await this.checkCriticalServices(instanceId)
    };
  }
}
```

##### 1.2 Endpoints de Diagn√≥stico Sob Demanda
```javascript
// Endpoint principal para executar diagn√≥stico manual
app.get('/api/instances/:id/run-diagnostics', authenticateToken, checkProjectAccess, async (req, res) => {
  try {
    console.log(`üîç Usu√°rio ${req.user.id} executando diagn√≥stico para inst√¢ncia ${req.params.id}`);
    
    const diagnostic = await instanceDiagnostics.runFullDiagnostic(req.params.id);
    
    res.json({
      success: true,
      message: 'Diagn√≥stico executado com sucesso',
      diagnostic: diagnostic
    });
  } catch (error) {
    console.error('‚ùå Erro no diagn√≥stico:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint para obter √∫ltimo diagn√≥stico (sem executar novo)
app.get('/api/instances/:id/last-diagnostic', authenticateToken, checkProjectAccess, async (req, res) => {
  try {
    const lastDiagnostic = await instanceDiagnostics.getLastDiagnostic(req.params.id);
    
    if (!lastDiagnostic) {
      return res.json({
        success: false,
        message: 'Nenhum diagn√≥stico recente. Execute um novo diagn√≥stico.',
        run_diagnostic_url: `/api/instances/${req.params.id}/run-diagnostics`
      });
    }
    
    res.json({
      success: true,
      diagnostic: lastDiagnostic
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Endpoint para diagn√≥stico de todas as inst√¢ncias (uso em cron)
app.get('/api/instances/check-all-health', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const instances = Object.keys(manager.instances);
    const results = [];
    
    for (const instanceId of instances) {
      const diagnostic = await instanceDiagnostics.runFullDiagnostic(instanceId);
      results.push({
        instance_id: instanceId,
        instance_name: manager.instances[instanceId].name,
        healthy: diagnostic.results.service_health.overall_healthy,
        issues: diagnostic.results.service_health.issues || []
      });
    }
    
    res.json({
      success: true,
      timestamp: new Date().toISOString(),
      total_instances: instances.length,
      results: results
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

##### 1.3 Sistema de Logs Estruturados (Sob Demanda)
```javascript
// Endpoint para an√°lise de logs sob demanda
app.get('/api/instances/:id/diagnostic-logs', authenticateToken, checkProjectAccess, async (req, res) => {
  try {
    const logs = await LogAnalyzer.getStructuredLogs(req.params.id, {
      services: req.query.services ? req.query.services.split(',') : ['auth', 'rest', 'db', 'kong'],
      level: req.query.level || 'error',
      timeRange: req.query.range || '1h'
    });
    
    res.json({
      success: true,
      logs: logs,
      summary: {
        total_entries: logs.length,
        error_count: logs.filter(log => log.level === 'error').length,
        warning_count: logs.filter(log => log.level === 'warning').length
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

##### 1.4 Agendamento Opcional via Cron
```bash
# Exemplo de configura√ß√£o cron para verifica√ß√£o a cada 6 horas
# Adicionar ao crontab do sistema (opcional)

# Diagn√≥stico geral de todas as inst√¢ncias a cada 6h
0 */6 * * * curl -H "Authorization: Bearer YOUR_ADMIN_TOKEN" http://localhost:3080/api/instances/check-all-health > /var/log/ultrabase-health.log 2>&1

# Diagn√≥stico de inst√¢ncia espec√≠fica se necess√°rio
0 */6 * * * curl -H "Authorization: Bearer YOUR_TOKEN" http://localhost:3080/api/instances/INSTANCE_ID/run-diagnostics > /var/log/ultrabase-instance-health.log 2>&1
```

#### Arquivos Modificados
- `src/server.js`: Adicionar classe `InstanceDiagnostics`
- Novo arquivo: `src/diagnostics/health-checker.js`
- Novo arquivo: `src/diagnostics/log-analyzer.js`

#### Riscos e Mitiga√ß√µes
- **Risco**: Sobrecarga do sistema com muitas verifica√ß√µes simult√¢neas
- **Mitiga√ß√£o**: Cache de resultados por 5 minutos, execu√ß√£o sob demanda apenas
- **Risco**: Timeouts em verifica√ß√µes de rede
- **Mitiga√ß√£o**: Timeouts configur√°veis (padr√£o 5s), execu√ß√£o ass√≠ncrona
- **Risco**: Usu√°rios executando diagn√≥sticos desnecess√°rios
- **Mitiga√ß√£o**: Rate limiting (1 diagn√≥stico por inst√¢ncia a cada 2 minutos)

---

### **FASE 2: Sistema de Controle e Gest√£o**
*Prioridade: ALTA*

#### Objetivo
Implementar controles seguros para gerenciar inst√¢ncias sem perda de dados.

#### Implementa√ß√µes T√©cnicas

##### 2.1 Opera√ß√µes Seguras de Controle
```javascript
class SafeInstanceManager extends SupabaseInstanceManager {
  async safeRestart(instanceId) {
    // 1. Backup autom√°tico de configura√ß√µes
    await this.backupInstanceConfig(instanceId);
    
    // 2. Verifica√ß√£o de estado antes da parada
    const preStopState = await this.captureInstanceState(instanceId);
    
    // 3. Parada graceful com timeout
    await this.gracefulStop(instanceId, 30000);
    
    // 4. Verifica√ß√£o de integridade dos volumes
    await this.verifyVolumeIntegrity(instanceId);
    
    // 5. Restart com verifica√ß√£o de sa√∫de
    await this.startWithHealthCheck(instanceId);
    
    // 6. Verifica√ß√£o p√≥s-restart
    return await this.verifyPostRestartState(instanceId, preStopState);
  }
  
  async repairInstance(instanceId) {
    const issues = await this.diagnostics.identifyIssues(instanceId);
    const repairActions = await this.planRepairActions(issues);
    
    for (const action of repairActions) {
      await this.executeRepairAction(instanceId, action);
      await this.verifyRepairResult(instanceId, action);
    }
  }
}
```

##### 2.2 Editor de Configura√ß√µes Seguro
```javascript
// Endpoint para edi√ß√£o segura de configura√ß√µes
app.put('/api/instances/:id/config', authenticateToken, checkProjectAccess, async (req, res) => {
  const { field, value } = req.body;
  
  // Valida√ß√£o de campos permitidos
  const allowedFields = ['name', 'dashboard_username', 'dashboard_password'];
  if (!allowedFields.includes(field)) {
    return res.status(400).json({ error: 'Campo n√£o edit√°vel' });
  }
  
  // Backup da configura√ß√£o atual
  await instanceManager.backupInstanceConfig(req.params.id);
  
  // Aplica√ß√£o da mudan√ßa
  const result = await instanceManager.updateInstanceConfig(req.params.id, field, value);
  
  // Verifica√ß√£o se a inst√¢ncia ainda funciona
  const healthCheck = await instanceManager.diagnostics.quickHealthCheck(req.params.id);
  
  if (!healthCheck.healthy) {
    // Rollback autom√°tico
    await instanceManager.rollbackInstanceConfig(req.params.id);
    return res.status(500).json({ error: 'Mudan√ßa causou problemas, rollback executado' });
  }
  
  res.json(result);
});
```

##### 2.3 Sistema de Backup e Rollback
- **Backup Autom√°tico**: Antes de qualquer opera√ß√£o cr√≠tica
- **Snapshot de Estado**: Captura estado completo da inst√¢ncia
- **Rollback Seguro**: Restaura√ß√£o autom√°tica em caso de falha

#### Arquivos Modificados
- `src/server.js`: Extens√£o da classe principal
- Novo arquivo: `src/management/safe-manager.js`
- Novo arquivo: `src/management/config-editor.js`
- Novo arquivo: `src/management/backup-system.js`

#### Riscos e Mitiga√ß√µes
- **Risco**: Corrup√ß√£o durante backup/rollback
- **Mitiga√ß√£o**: Verifica√ß√£o de integridade, backups m√∫ltiplos
- **Risco**: Perda de dados durante restart
- **Mitiga√ß√£o**: Verifica√ß√£o de volume, parada graceful

---

### **FASE 3: Dashboard de Monitoramento**
*Prioridade: M√âDIA*

#### Objetivo
Interface visual para monitoramento e controle das inst√¢ncias.

#### Implementa√ß√µes T√©cnicas

##### 3.1 Dashboard de Diagn√≥stico Sob Demanda
```html
<!-- Adi√ß√£o ao index.html - Se√ß√£o de diagn√≥stico por inst√¢ncia -->
<div class="instance-card" data-instance="${instanceId}">
  <div class="instance-header">
    <h3>${instanceName}</h3>
    <span class="instance-status ${status}">${status}</span>
  </div>
  
  <!-- Controles de Diagn√≥stico -->
  <div class="diagnostic-controls">
    <button class="btn-primary run-diagnostic-btn" 
            onclick="controlPanel.runDiagnostics('${instanceId}')">
      üîç Executar Diagn√≥stico Agora
    </button>
    
    <button class="btn-secondary" 
            onclick="controlPanel.showLastDiagnostic('${instanceId}')">
      üìä Ver √öltimo Diagn√≥stico
    </button>
    
    <button class="btn-tertiary" 
            onclick="controlPanel.showDiagnosticHistory('${instanceId}')">
      üìà Hist√≥rico
    </button>
  </div>
  
  <!-- √Årea de Resultados (carregada sob demanda) -->
  <div class="diagnostic-results" style="display: none;">
    <!-- Resultados ser√£o carregados aqui dinamicamente -->
  </div>
  
  <!-- Controles de A√ß√£o -->
  <div class="action-controls" style="display: none;">
    <button class="btn-warning" 
            onclick="controlPanel.safeRestart('${instanceId}')">
      üîÑ Restart Seguro
    </button>
    
    <button class="btn-info" 
            onclick="controlPanel.showLogs('${instanceId}')">
      üìù Ver Logs
    </button>
  </div>
</div>
```

##### 3.2 Controle de Inst√¢ncias com Diagn√≥stico Sob Demanda
```javascript
// JavaScript para interface de controle
class InstanceControlPanel {
  constructor() {
    this.diagnosticInProgress = new Set(); // Evitar m√∫ltiplas execu√ß√µes
  }

  async runDiagnostics(instanceId) {
    if (this.diagnosticInProgress.has(instanceId)) {
      this.showWarning('Diagn√≥stico j√° em execu√ß√£o para esta inst√¢ncia');
      return;
    }

    const diagnosticButton = document.querySelector(`[data-instance="${instanceId}"] .run-diagnostic-btn`);
    diagnosticButton.disabled = true;
    diagnosticButton.textContent = 'Executando...';
    
    this.diagnosticInProgress.add(instanceId);

    try {
      const response = await fetch(`/api/instances/${instanceId}/run-diagnostics`);
      const data = await response.json();
      
      if (data.success) {
        this.renderDiagnosticResults(instanceId, data.diagnostic);
        this.showSuccess('Diagn√≥stico executado com sucesso');
      } else {
        this.showError('Falha no diagn√≥stico');
      }
    } catch (error) {
      this.showError(`Erro no diagn√≥stico: ${error.message}`);
    } finally {
      this.diagnosticInProgress.delete(instanceId);
      diagnosticButton.disabled = false;
      diagnosticButton.textContent = 'Executar Diagn√≥stico Agora';
    }
  }

  async showLastDiagnostic(instanceId) {
    try {
      const response = await fetch(`/api/instances/${instanceId}/last-diagnostic`);
      const data = await response.json();
      
      if (data.success && data.diagnostic) {
        this.renderDiagnosticResults(instanceId, data.diagnostic);
      } else {
        this.showInfo('Nenhum diagn√≥stico recente. Execute um novo diagn√≥stico.');
      }
    } catch (error) {
      this.showError(`Erro ao carregar diagn√≥stico: ${error.message}`);
    }
  }

  renderDiagnosticResults(instanceId, diagnostic) {
    const resultsContainer = document.querySelector(`[data-instance="${instanceId}"] .diagnostic-results`);
    const timestamp = new Date(diagnostic.timestamp).toLocaleString('pt-BR');
    
    let html = `
      <div class="diagnostic-header">
        <h4>Diagn√≥stico - ${timestamp}</h4>
        <button class="btn-secondary" onclick="controlPanel.showLastDiagnostic('${instanceId}')">
          Atualizar Resultados
        </button>
      </div>
      <div class="health-cards">
    `;

    // Renderizar cards de sa√∫de
    Object.entries(diagnostic.results).forEach(([service, result]) => {
      const status = result.healthy ? 'healthy' : 'unhealthy';
      const icon = result.healthy ? '‚úÖ' : '‚ùå';
      
      html += `
        <div class="health-card ${status}">
          <div class="service-name">${icon} ${service.replace('_', ' ').toUpperCase()}</div>
          <div class="service-status">${result.status || 'N/A'}</div>
          ${result.issues ? `<div class="issues">${result.issues.join(', ')}</div>` : ''}
        </div>
      `;
    });

    html += '</div>';
    resultsContainer.innerHTML = html;
  }
  
  async safeRestart(instanceId) {
    if (!confirm('Confirma restart seguro da inst√¢ncia?')) return;
    
    const progressModal = this.showProgressModal();
    
    try {
      const result = await fetch(`/api/instances/${instanceId}/safe-restart`, {
        method: 'POST'
      });
      
      if (result.ok) {
        this.showSuccess('Inst√¢ncia reiniciada com sucesso');
        // Executar diagn√≥stico ap√≥s restart para verificar sa√∫de
        setTimeout(() => this.runDiagnostics(instanceId), 2000);
      } else {
        this.showError('Falha no restart');
      }
    } finally {
      progressModal.close();
    }
  }
}

// Inst√¢ncia global
const controlPanel = new InstanceControlPanel();
```

#### Arquivos Modificados
- `src/public/index.html`: Adicionar se√ß√µes de diagn√≥stico
- Novo arquivo: `src/public/js/diagnostics.js`
- Novo arquivo: `src/public/css/diagnostics.css`

---

### **FASE 4: Sistema de Relat√≥rios e Hist√≥rico**
*Prioridade: BAIXA | Dura√ß√£o: 2-3 dias*

#### Objetivo
Sistema de relat√≥rios hist√≥ricos e an√°lise de tend√™ncias baseado em diagn√≥sticos executados.

#### Implementa√ß√µes T√©cnicas

##### 4.1 Hist√≥rico de Diagn√≥sticos
```javascript
class DiagnosticHistory {
  constructor() {
    this.historyFile = path.join(__dirname, 'diagnostic-history.json');
    this.maxHistoryEntries = 100; // Por inst√¢ncia
  }
  
  async saveDiagnostic(instanceId, diagnostic) {
    const history = await this.loadHistory();
    
    if (!history[instanceId]) {
      history[instanceId] = [];
    }
    
    // Adicionar novo diagn√≥stico
    history[instanceId].unshift({
      ...diagnostic,
      id: uuidv4().substring(0, 8)
    });
    
    // Limitar hist√≥rico
    if (history[instanceId].length > this.maxHistoryEntries) {
      history[instanceId] = history[instanceId].slice(0, this.maxHistoryEntries);
    }
    
    await this.saveHistory(history);
  }
  
  async generateHealthReport(instanceId, days = 7) {
    const history = await this.loadHistory();
    const instanceHistory = history[instanceId] || [];
    
    const cutoffDate = new Date(Date.now() - (days * 24 * 60 * 60 * 1000));
    const recentDiagnostics = instanceHistory.filter(d => 
      new Date(d.timestamp) > cutoffDate
    );
    
    return {
      instance_id: instanceId,
      period_days: days,
      total_diagnostics: recentDiagnostics.length,
      health_trend: this.calculateHealthTrend(recentDiagnostics),
      most_common_issues: this.getMostCommonIssues(recentDiagnostics),
      uptime_percentage: this.calculateUptimePercentage(recentDiagnostics)
    };
  }
}
```

##### 4.2 Endpoints de Relat√≥rio
```javascript
// Endpoint para hist√≥rico de diagn√≥sticos
app.get('/api/instances/:id/diagnostic-history', authenticateToken, checkProjectAccess, async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;
    const history = await diagnosticHistory.getInstanceHistory(req.params.id, limit);
    
    res.json({
      success: true,
      history: history
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Endpoint para relat√≥rio de sa√∫de
app.get('/api/instances/:id/health-report', authenticateToken, checkProjectAccess, async (req, res) => {
  try {
    const days = parseInt(req.query.days) || 7;
    const report = await diagnosticHistory.generateHealthReport(req.params.id, days);
    
    res.json({
      success: true,
      report: report
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

##### 4.3 Agendamento Opcional de Diagn√≥sticos
```javascript
// Classe opcional para agendamento (sem execu√ß√£o autom√°tica)
class ScheduledDiagnostics {
  constructor() {
    this.schedules = new Map(); // Armazena configura√ß√µes, n√£o executa
  }
  
  // Criar configura√ß√£o de agendamento (para uso com cron externo)
  createScheduleConfig(instanceId, interval = '6h') {
    const config = {
      instance_id: instanceId,
      interval: interval,
      command: `curl -H "Authorization: Bearer TOKEN" http://localhost:3080/api/instances/${instanceId}/run-diagnostics`,
      cron_expression: this.intervalToCron(interval),
      created_at: new Date().toISOString()
    };
    
    this.schedules.set(instanceId, config);
    return config;
  }
  
  intervalToCron(interval) {
    const intervalMap = {
      '1h': '0 * * * *',
      '6h': '0 */6 * * *',
      '12h': '0 */12 * * *',
      '24h': '0 0 * * *'
    };
    
    return intervalMap[interval] || '0 */6 * * *';
  }
  
  // Gerar script de cron para o usu√°rio
  generateCronScript(instanceId) {
    const config = this.schedules.get(instanceId);
    if (!config) return null;
    
    return `# Diagn√≥stico autom√°tico para inst√¢ncia ${instanceId}
${config.cron_expression} ${config.command} >> /var/log/ultrabase-diagnostic-${instanceId}.log 2>&1`;
  }
}
```

##### 4.4 Interface de Configura√ß√£o de Agendamento
```html
<!-- Adi√ß√£o ao dashboard para configurar agendamento -->
<div class="schedule-config">
  <h4>Agendamento de Diagn√≥sticos (Opcional)</h4>
  <p>Configure diagn√≥sticos autom√°ticos via cron system:</p>
  
  <select id="diagnostic-interval">
    <option value="6h">A cada 6 horas</option>
    <option value="12h">A cada 12 horas</option>
    <option value="24h">Diariamente</option>
  </select>
  
  <button onclick="generateCronConfig(instanceId)">Gerar Configura√ß√£o Cron</button>
  
  <div id="cron-output" class="code-block hidden">
    <!-- Script cron ser√° exibido aqui -->
  </div>
</div>
```

---

## Cronograma de Implementa√ß√£o

| Fase | Dura√ß√£o | Depend√™ncias | Riscos |
|------|---------|--------------|--------|
| Fase 1 | 3-5 dias | Nenhuma | Baixo |
| Fase 2 | 4-6 dias | Fase 1 completa | M√©dio |
| Fase 3 | 3-4 dias | Fases 1-2 completas | Baixo |
| Fase 4 | 2-3 dias | Fases 1-3 completas | Baixo |
| **Total** | **12-18 dias** | | |

---

## Garantias de Seguran√ßa

### 1. **Preserva√ß√£o de Dados**
- ‚úÖ Backup autom√°tico antes de qualquer opera√ß√£o cr√≠tica
- ‚úÖ Verifica√ß√£o de integridade de volumes Docker
- ‚úÖ Rollback autom√°tico em caso de falha
- ‚úÖ Parada graceful com timeout configur√°vel

### 2. **Opera√ß√µes N√£o Destrutivas**
- ‚úÖ Diagn√≥sticos s√£o read-only
- ‚úÖ Restart usa `docker compose restart` (preserva volumes)
- ‚úÖ Configura√ß√µes mant√™m compatibilidade
- ‚úÖ Logs de auditoria para todas as opera√ß√µes

### 3. **Valida√ß√£o Cont√≠nua**
- ‚úÖ Health checks ap√≥s cada opera√ß√£o
- ‚úÖ Verifica√ß√£o de conectividade de servi√ßos
- ‚úÖ Teste de integridade de dados
- ‚úÖ Monitoramento p√≥s-opera√ß√£o

### 4. **Controle de Acesso**
- ‚úÖ Opera√ß√µes cr√≠ticas requerem autentica√ß√£o
- ‚úÖ Logs de auditoria de todas as a√ß√µes
- ‚úÖ Controle de permiss√µes por usu√°rio
- ‚úÖ Rate limiting para opera√ß√µes sens√≠veis

---

## Estrutura de Arquivos Ap√≥s Implementa√ß√£o

```
src/
‚îú‚îÄ‚îÄ server.js (modificado)
‚îú‚îÄ‚îÄ diagnostics/
‚îÇ   ‚îú‚îÄ‚îÄ health-checker.js (novo)
‚îÇ   ‚îú‚îÄ‚îÄ log-analyzer.js (novo)
‚îÇ   ‚îú‚îÄ‚îÄ diagnostic-history.js (novo)
‚îÇ   ‚îî‚îÄ‚îÄ scheduled-diagnostics.js (novo)
‚îú‚îÄ‚îÄ management/
‚îÇ   ‚îú‚îÄ‚îÄ safe-manager.js (novo)
‚îÇ   ‚îú‚îÄ‚îÄ config-editor.js (novo)
‚îÇ   ‚îú‚îÄ‚îÄ backup-system.js (novo)
‚îÇ   ‚îî‚îÄ‚îÄ repair-engine.js (novo)
‚îî‚îÄ‚îÄ public/
    ‚îú‚îÄ‚îÄ index.html (modificado - bot√µes de diagn√≥stico)
    ‚îú‚îÄ‚îÄ js/
    ‚îÇ   ‚îú‚îÄ‚îÄ diagnostics.js (novo)
    ‚îÇ   ‚îî‚îÄ‚îÄ instance-control.js (novo)
    ‚îî‚îÄ‚îÄ css/
        ‚îî‚îÄ‚îÄ diagnostics.css (novo)
```

---

## Resolu√ß√£o do Problema Espec√≠fico

### "Failed to create user: API error happened while trying to communicate with the server"

#### Diagn√≥stico Automatizado
Com as melhorias implementadas, o sistema poder√° automaticamente:

1. **Verificar Status do GoTrue**
   ```bash
   GET /api/instances/{id}/diagnostics/auth
   ```
   - Container status
   - Health endpoint response
   - Database connection
   - JWT configuration

2. **Analisar Logs Espec√≠ficos**
   ```bash
   GET /api/instances/{id}/logs?service=auth&level=error&range=1h
   ```
   - Filtrar logs do GoTrue
   - Identificar padr√µes de erro
   - Correlacionar com outros servi√ßos

3. **Teste de Conectividade**
   ```bash
   POST /api/instances/{id}/test/user-creation
   ```
   - Simular cria√ß√£o de usu√°rio
   - Validar response
   - Identificar ponto de falha

#### A√ß√µes de Reparo Automatizadas
1. **Restart do Servi√ßo Auth**: Se container n√£o responde
2. **Verifica√ß√£o de Configura√ß√£o**: JWT secrets, database URL
3. **Teste de Database**: Conectividade e permiss√µes
4. **Regenera√ß√£o de Tokens**: Se JWT inv√°lido

---

## Conclus√£o

Este plano oferece uma solu√ß√£o completa para os problemas de diagn√≥stico e controle do gerenciador de inst√¢ncias, mantendo a m√°xima seguran√ßa e confiabilidade do sistema. A implementa√ß√£o ser√° incremental, permitindo testes e valida√ß√£o a cada etapa.

### Benef√≠cios Esperados
- üéØ **Diagn√≥stico sob demanda** preciso e detalhado de problemas
- üõ°Ô∏è **Zero downtime** desnecess√°rio com opera√ß√µes seguras
- üìä **Visibilidade controlada** do estado das inst√¢ncias
- üîß **Reparo assistido** de problemas comuns
- üìà **Prepara√ß√£o para produ√ß√£o** com controle total do usu√°rio
- ‚ö° **Performance otimizada** sem overhead de monitoramento cont√≠nuo
- üéõÔ∏è **Controle total** sobre quando executar diagn√≥sticos

### Pr√≥ximos Passos
1. **Aprova√ß√£o do plano** pelo usu√°rio
2. **Implementa√ß√£o da Fase 1** (diagn√≥stico b√°sico)
3. **Testes em ambiente de desenvolvimento**
4. **Implementa√ß√£o incremental das demais fases**
5. **Documenta√ß√£o final** e treinamento